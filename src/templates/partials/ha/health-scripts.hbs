{{!-- Health Monitoring Helper Scripts --}}
{{!-- Provides template scripts for custom health monitoring --}}

{{#*inline "linuxHealthScript"}}
#!/bin/bash
# Custom Health Monitoring Script for Linux
# Generated by azmp-plugin-vm v1.11.0

set -e

LOG_FILE="/var/log/health-monitor.log"
HEALTH_STATUS_FILE="/tmp/health-status"
MAX_LOG_SIZE=10485760  # 10MB

# Rotate log if too large
if [ -f "$LOG_FILE" ] && [ $(stat -f%z "$LOG_FILE" 2>/dev/null || stat -c%s "$LOG_FILE" 2>/dev/null || echo 0) -gt $MAX_LOG_SIZE ]; then
    mv "$LOG_FILE" "${LOG_FILE}.old"
fi

log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> "$LOG_FILE"
}

check_health() {
    local status=0
    local message="Health check passed"
    
    {{#if customHealthProbe.httpEndpoint}}
    # HTTP Health Check
    local http_url="{{customHealthProbe.httpEndpoint.url}}"
    local expected_status={{default customHealthProbe.httpEndpoint.expectedStatusCode 200}}
    local timeout={{default customHealthProbe.httpEndpoint.timeoutSeconds 30}}
    
    log_message "Checking HTTP endpoint: $http_url"
    
    if command -v curl >/dev/null 2>&1; then
        response=$(curl -s -o /dev/null -w "%{http_code}" --max-time $timeout "$http_url" || echo "000")
        if [ "$response" != "$expected_status" ]; then
            status=1
            message="HTTP health check failed: expected $expected_status, got $response"
        fi
    else
        log_message "curl not available, skipping HTTP health check"
    fi
    {{/if}}
    
    {{#if customHealthProbe.script}}
    # Custom Script Health Check
    {{#if customHealthProbe.script.command}}
    log_message "Running custom health script: {{customHealthProbe.script.command}}"
    if ! {{customHealthProbe.script.command}}; then
        status=1
        message="Custom script health check failed"
    fi
    {{/if}}
    {{/if}}
    
    {{#if customHealthProbe.serviceChecks}}
    # Service Health Checks
    {{#each customHealthProbe.serviceChecks}}
    log_message "Checking service: {{this}}"
    if ! systemctl is-active --quiet "{{this}}"; then
        status=1
        message="Service {{this}} is not running"
        break
    fi
    {{/each}}
    {{/if}}
    
    {{#if customHealthProbe.portChecks}}
    # Port Health Checks
    {{#each customHealthProbe.portChecks}}
    log_message "Checking port: {{this}}"
    if ! nc -z localhost {{this}} >/dev/null 2>&1; then
        status=1
        message="Port {{this}} is not accessible"
        break
    fi
    {{/each}}
    {{/if}}
    
    # Write health status
    echo "{\"status\": $status, \"message\": \"$message\", \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}" > "$HEALTH_STATUS_FILE"
    log_message "$message (status: $status)"
    
    return $status
}

# Main execution
log_message "Starting health monitoring check"

if check_health; then
    log_message "Health check completed successfully"
    exit 0
else
    log_message "Health check failed"
    exit 1
fi
{{/inline}}

{{#*inline "windowsHealthScript"}}
# Custom Health Monitoring Script for Windows
# Generated by azmp-plugin-vm v1.11.0

$ErrorActionPreference = "Stop"
$LogFile = "C:\Windows\Temp\health-monitor.log"
$HealthStatusFile = "C:\Windows\Temp\health-status.json"
$MaxLogSize = 10MB

# Rotate log if too large
if (Test-Path $LogFile) {
    $logSize = (Get-Item $LogFile).Length
    if ($logSize -gt $MaxLogSize) {
        Move-Item $LogFile "$LogFile.old" -Force
    }
}

function Log-Message {
    param([string]$Message)
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    "$timestamp - $Message" | Out-File -FilePath $LogFile -Append -Encoding utf8
}

function Test-Health {
    $status = 0
    $message = "Health check passed"
    
    try {
        {{#if customHealthProbe.httpEndpoint}}
        # HTTP Health Check
        $httpUrl = "{{customHealthProbe.httpEndpoint.url}}"
        $expectedStatus = {{default customHealthProbe.httpEndpoint.expectedStatusCode 200}}
        $timeout = {{default customHealthProbe.httpEndpoint.timeoutSeconds 30}}
        
        Log-Message "Checking HTTP endpoint: $httpUrl"
        
        try {
            $response = Invoke-WebRequest -Uri $httpUrl -TimeoutSec $timeout -UseBasicParsing
            if ($response.StatusCode -ne $expectedStatus) {
                $status = 1
                $message = "HTTP health check failed: expected $expectedStatus, got $($response.StatusCode)"
            }
        }
        catch {
            $status = 1
            $message = "HTTP health check failed: $($_.Exception.Message)"
        }
        {{/if}}
        
        {{#if customHealthProbe.script}}
        # Custom Script Health Check
        {{#if customHealthProbe.script.command}}
        Log-Message "Running custom health script: {{customHealthProbe.script.command}}"
        try {
            $result = Invoke-Expression "{{customHealthProbe.script.command}}"
            if ($LASTEXITCODE -ne 0) {
                $status = 1
                $message = "Custom script health check failed"
            }
        }
        catch {
            $status = 1
            $message = "Custom script health check failed: $($_.Exception.Message)"
        }
        {{/if}}
        {{/if}}
        
        {{#if customHealthProbe.serviceChecks}}
        # Service Health Checks
        {{#each customHealthProbe.serviceChecks}}
        Log-Message "Checking service: {{this}}"
        $service = Get-Service -Name "{{this}}" -ErrorAction SilentlyContinue
        if (-not $service -or $service.Status -ne "Running") {
            $status = 1
            $message = "Service {{this}} is not running"
            break
        }
        {{/each}}
        {{/if}}
        
        {{#if customHealthProbe.portChecks}}
        # Port Health Checks
        {{#each customHealthProbe.portChecks}}
        Log-Message "Checking port: {{this}}"
        $tcpClient = New-Object System.Net.Sockets.TcpClient
        try {
            $tcpClient.ConnectAsync("localhost", {{this}}).Wait(5000)
            if (-not $tcpClient.Connected) {
                $status = 1
                $message = "Port {{this}} is not accessible"
                break
            }
        }
        catch {
            $status = 1
            $message = "Port {{this}} is not accessible"
            break
        }
        finally {
            $tcpClient.Close()
        }
        {{/each}}
        {{/if}}
        
    }
    catch {
        $status = 1
        $message = "Health check error: $($_.Exception.Message)"
    }
    
    # Write health status
    $healthStatus = @{
        status = $status
        message = $message
        timestamp = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")
    }
    
    $healthStatus | ConvertTo-Json | Out-File -FilePath $HealthStatusFile -Encoding utf8
    Log-Message "$message (status: $status)"
    
    return $status
}

# Main execution
Log-Message "Starting health monitoring check"

if (Test-Health -eq 0) {
    Log-Message "Health check completed successfully"
    exit 0
} else {
    Log-Message "Health check failed"
    exit 1
}
{{/inline}}

{{!-- Generate appropriate script based on OS --}}
{{#if osProfile.isLinux}}
{{> linuxHealthScript}}
{{else}}
{{> windowsHealthScript}}
{{/if}}